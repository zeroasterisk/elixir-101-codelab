doctype html
html
  head
    meta(charset='utf-8')
    meta(name='viewport', content='width=device-width, initial-scale=1, maximum-scale=1')
    title Elixir 101 (slides)

    link(rel='stylesheet', type='text/css', href='build/build.css')

  style.
    .hello {
      /* background-image: url('images/hello-tharr.gif') */
      background-image: url('images/cuttlefish.gif')
    }
    div.elixir {
      background-image: url('images/elixir-logo.png')
    }
    .erlang {
      background-image: url('images/erlang-logo.png')
    }
    .yawn {
      background-image: url('images/yawn.gif')
    }
    .example {
      background-image: url('images/example.gif')
    }
    .star-loop {
      background-image: url('images/star-loop.gif')
    }
    .sad-kirk {
      background-image: url('images/sad-kirk.gif')
    }
    .happy-kirk {
      background-image: url('images/happy-kirk.gif')
    }
    .nye {
      background-image: url('images/nye.gif')
    }
    .package {
      background-image: url('images/package.gif')
    }
    .mind-blown {
      background-image: url('images/mind-blown.gif')
    }
    .universe {
      background-image: url('images/universe.gif')
    }
    .babel {
      background-image: url('images/babel.gif')
    }
    .bear {
      background-image: url('images/bear.gif')
    }

  body

    article

      section
        h2 Elixir 101
        h3 What, Why, &amp; How
        h4 What to know, before you codelab
        p Alan Blount
          a(href='https://twitter.com/zeroaterisk') @zeroasterisk

      section(data-bespoke-backdrop='hello')
        h1 Hi.

      section
        h1 My Name is Alan
        img.headroom(src='images/alan-slipnslide.jpg' alt='alan jumping' height='250px')

      section
        h3 I am employed by Google as a Technical Program Manager
        h4 Payments Backend &amp; Banking Integrations

        img(src='images/google-pay-logo.png' alt='Google Payments' height='200px' style='background-color:white;')

        h5.headroom The opinions expressed in this talk are solely my own

      section
        h1 Let's Jump Right In
        img.headroom(src='images/alan-cliff-jump.jpg' alt='alan jumping' height='250px')

      section(data-bespoke-backdrop='elixir')
        h1 What is Elixir?

      section(data-bespoke-backdrop='elixir')
        h2
          img.headroom(src='images/elixir-logo-text.png' alt='elixir logo' height='100px'
          style='background-color:white; padding: 0.5em 1.7em;')
        ul
          li.hide
          li Typed &amp; Immutable(mostly)
          li Functional
          li Ruby(ish) Syntax <em>(focus on readability)</em>
          li Built on Erlang &amp; runs on the BEAM VM.

      section(data-bespoke-backdrop='elixir')
        h2
          img.headroom(src='images/elixir-to-erlang-compile.png' alt='elixir compile steps' height='200px' style='background-color:white;')
        h3 Elixir is (mostly) macros on Erlang

      section(data-bespoke-backdrop='erlang')
        h1 What is Erlang?

      section(data-bespoke-backdrop='erlang')
        h2
          img.headroom(src='images/erlang-logo.png' alt='erlang logo' height='100px'
          style='background-color:white; padding: 0.5em 1.7em;')
        h3 Erlang is...
        ul
          li.hide
          li Both a Language + VM (BEAM)
          li Created by Ericson in 1986 &amp; open sourced in 1998
          li It has been in many massive production systems for 20+ years
          li Widely adopted by telcom &amp; communications
          li Used in systems like distributed DBs, high-frequency trading, etc

      section(data-bespoke-backdrop='erlang')
        h2
          img.headroom(src='images/erlang-logo.png' alt='erlang logo' height='100px'
          style='background-color:white; padding: 0.5em 1.7em;')
        h3 Erlang Key Features
        ul
          li.hide
          li Soft Real-Time
          li Clustering built in
          li Light weight message passing built in
          li Pure Actor Model
          li OTP (Open Telecom Platform) system for supervisors/processes
          li Fault-tolerance (let it die)

      section(data-bespoke-backdrop='erlang')
        blockquote "At the time of writing the largest of these projects is a major
          | Ericsson product, having over a million lines of Erlang code.
          | This product (the AXD301) is thought to be
          | <u>one of the most reliable products ever made by Ericsson</u>
        blockquote "Switching systems should run with an acceptable level of service even in the
          | presence of errors. Telephone exchanges are expected to be extremely reliable. Typically
          | <u>having less than two hours of down-time in 40 years</u>."
        p(style='text-align=right;margin-top:1em;') &mdash;
          | Joe Armstrong (creator of Erlang)<br/>
          | in his 2003 thesis about the creation of Erlang

      section(data-bespoke-backdrop='erlang')
        blockquote "If somebody came to me and wanted to pay me a lot of money to
          | build a large scale message handling system that really had to be up
          | all the time, could never afford to go down for years at a time,
          | <u>I would unhesitatingly choose Erlang to build it in</u>."
        p(style='text-align=right;margin-top:1em;') &mdash;
          | Tim Bray, director of Web Technologies at Sun Microsystems<br/>
          | in his 2008 keynote at OSCON

      section(data-bespoke-backdrop='star-loop')
        h2 Ericsson AXD
        h3 control plane of an ATM switch
        ul
          li.hide
          li 99.9999999% (9-nines) availability
          li Concurrent, distributed, soft real-time

      section(data-bespoke-backdrop='star-loop')
        h2 Cisco
        h3 Shipping 2m devices/year with Erlang
        ul
          li.hide
          li 90% of <u>all internet traffic</u> goes through Erlang controlled nodes
          li Top 8 Service Providers use Erlang to control their networks
          li top 8 Network Equipment Providers use Erlang based components

      section(data-bespoke-backdrop='star-loop')
        h2 Whatsapp
        h3 Built Using Erlang
        ul
          li.hide
          li 465M monthly users, 14B(in) &amp; 40B(out) msgs/day
          li 230k peak logins/sec
          li 147M peak concurrent connections
          li 1M+ persistent concurrent connections <em>per server</em>
          li Less than 50 engineers

      section(data-bespoke-backdrop='package')
        h1 Why Elixir, and not just use Erlang?

      section(data-bespoke-backdrop='elixir')
        h3 José Valim created the Elixir programming language, beginning as an R&D project at Plataformatec.
        h4 Goal: <u>enable higher extensibility and productivity</u> while keeping compatibility with Erlang's ecosystem.

      section(data-bespoke-backdrop='elixir')
        blockquote "Erlang’s syntax derived from Prolog and was heavily influenced by Smalltalk, CSP and functional programming. Elixir is heavily influenced by Erlang and Ruby.
        blockquote "From Erlang it brings pattern matching, higher order functions and the entire process and error handling “let it crash” philosophy. From Ruby it brings sigils, and shortcut syntaxes. It also adds a few goodies of its own, the |> pipe operator, reminiscent of Prolog’s DCGs and Haskell monads (though less complicated, more like the good old unix pipe operator) and the macro quote and unquote operators, which come from the lisp quasiquote and comma operators."
        p(style='text-align=right;margin-top:1em;') &mdash;
          a(href='http://joearms.github.io/2013/05/31/a-week-with-elixir.html')
            | Joe Armstrong (2013)

      section(data-bespoke-backdrop='elixir')
        h2 Elixir is a new language built on top of some very good ideas.

      section(data-bespoke-backdrop='elixir')
        h2 It is also simpler
        ul
          li.hide
          li Several macros in Elixir make it easier to use
          li Some of Elixir's structure enforce conventions
          li Elixir has reduced the footprint of Erlang you *need* to use
          li And Erlang has reduced a lot of functionality needed for parallel processing

      section(data-bespoke-backdrop='star-loop')
        h2 Pinterest
        h3 Rewrote their notification system in Elixir
        ul
          li.hide
          li Handles 14k notifications per second
          li Uses half the number of servers as their previous Java implementation
          li The codebase is ~1/10<sup>th</sup> the size

      section(data-bespoke-backdrop='star-loop')
        h2 Bleacher Report
        h3 Recently converted from Ruby to Elixir
        ul
          li.hide
          li 1.5B pageviews/month
          li 200k concurrent connections to mobile app
          li Most heavily used service could handle 8x load per server
          li Now using ~1/10th the servers total, supporting more traffic
          li Traffic spikes which used to cause scaling, now handled normally
          li All streaming content deleivered in about 1/10th the time

      section(data-bespoke-backdrop='yawn')
        h2 Still not convinced...

      section(data-bespoke-backdrop='elixir')
        h1 Immutability
        p Very Testable, Easy to Parallelize, No Side Effects

      section(data-bespoke-backdrop='elixir')
        h1 Isolation
        p Immutability Allows Garbage Collection at Process Level
        h3 No big garbage collection pauses

      section(data-bespoke-backdrop='elixir')
        h1 Reliability
        h3 OTP Apps are Supervision Trees
        p
          img.headroom(src='images/observer-apps.png' alt='erlang logo' height='200px' style='background-color:white; padding: 0.5em 1.7em;')
        p Supervisors monitor/start/stop Child Workers/Supervisor

      section(data-bespoke-backdrop='elixir')
        h1 Single-Box Scalability
        p Often 100's of thousands to millions of processes per machine
        h3 ~2KB of stack/heap per thread

      section(data-bespoke-backdrop='elixir')
        h1 Hot Code Reloading
        h3 Update Production Without Restart

      section(data-bespoke-backdrop='elixir')
        h1 Debugging &amp; Tracing
        h3 Debug/Trace Production Without Restart
        p Read
          a(href='https://www.erlang-in-anger.com/')
            | Erlang in Anger
          | &nbsp;for production support tips
        p(style='margin-top:1em;')
          | <em>Also debug in dev with <code>pry</code><br/>
          | similar to JavaScript <code>debugger;</code></em>

      section(data-bespoke-backdrop='elixir')
        h1 Better Architecture -> Cleaner Code
        p Less "defensive programming"
        p Exception handling is rare

      section(data-bespoke-backdrop='elixir')
        h1 Functional Programming is <em>Fun</em>
        p Encourages smaller functions (readible/composable)
        p Testing is easier and faster
        p Side effects suck! Let's avoid them.

      section(data-bespoke-backdrop='elixir')
        h1 Developer Experience
        ul
          li.hide
          li Rhobust REPL, build system, &amp; package management
          li Tooling baked in: docs, testing, coverage, etc
          li Vibrant and supportive community
          li Very well documented
          li Fun to learn a new approach to programming
          li(style='text-align:right') (not new just syntax)

      section(data-bespoke-backdrop='babel')
        h1 Impressed?

      section(data-bespoke-backdrop='example')
        h1 Show me some examples

      // lifted from http://tednaleid.github.io/intro-to-elixir/
      section(data-bespoke-backdrop='elixir')
        h2 Basic Types
        pre
          code.elixir
            | iex> my_utf8_string = "hello Iñtërnâtiônàlizætiøn"
            | "hello Iñtërnâtiônàlizætiøn"
            | ­
            | iex> my_atom = :hello
            | :hello
            | ­
            | iex> 1000 == 1_000
            | true
            | ­
            | iex> 0.314159e1 == 314159.0e-5
            | true
            | ­
            | iex> my_range = 1..5
            | 1..5

      section(data-bespoke-backdrop='elixir')
        h2 Booleans &amp; nil
        pre
          code.elixir
            | iex> is_boolean(true) && is_atom(true)
            | true
            | iex> is_boolean(:true) && is_atom(:true)
            | true
            | iex> is_atom(True)
            | true
            | iex> is_boolean(True)
            | false
            |
            | iex> is_nil(nil) && is_atom(nil)
            | true
            | iex> is_boolean(nil)
            | false
            | true

      section(data-bespoke-backdrop='elixir')
        h2 Integer
        pre
          code.elixir
            | iex> is_integer(128)
            | true
            |
            | iex> 1000 == 1_000
            | true
            |
            | iex> 0b0110 # binary
            | 6
            |
            | iex> 0o644 # octal
            | 420
            |
            | iex> 0x1F # hexadecimal
            | 31

      section(data-bespoke-backdrop='elixir')
        h2 Floats
        pre
          code.elixir
            | iex> 3.14
            | 3.14
            |
            | iex> .14
            | ** (SyntaxError) iex:2: syntax error before: '.'
            |
            | iex> 1.0e-10
            | 1.0e-10
            |
            | iex> 0.1 * 0.1
            | 0.010000000000000002

      section(data-bespoke-backdrop='elixir')
        h2 Atoms
        p An atom is a constant whose name is its value. (Like Ruby Symbols)
        pre
          code.elixir
            | iex> :foo
            | :foo
            | iex> :foo == :bar
            | false
            | iex> :foo == "foo"
            | false
            | iex> :foo == :Foo
            | false
            | iex> :foo == Foo
            | false
            | iex> is_atom(:foo) && is_atom(:Foo) && is_atom(Foo)
            | true

      section(data-bespoke-backdrop='elixir')
        h2 Strings
        p Strings in Elixir are binarys delimited by double quotes, and they are encoded in UTF-8
        pre
          code.elixir
            | iex> hello = "dziękuję"
            | "dziękuję"
            |
            | iex> byte_size(hello)
            | 10
            |
            | iex> String.length(hello)
            | 8
            |
            | iex> is_bitstring(hello) && is_binary(hello)
            | true
            |
            | iex> "Here's #{hello} world"
            | "Here's dziękuję world"
            |
            | iex> ?a
            | 97
            |
            | iex> <<97, 97, 97 :: utf8>>
            | "aaa"
            |
            | iex> <<97, 97, 97>>
            | "aaa"

      section(data-bespoke-backdrop='elixir')
        h2 Charlist
        p A charlist is a list of code points, created with single-quoted literals
        pre
          code.elixir
            | iex> a = 'abcd'
            | 'abcd'
            |
            | iex> List.first(a)
            | 97
            |
            | iex> to_string(a)
            | "abcd"
            |
            | iex> byte_size(a)
            | ** (ArgumentError) argument error
            |    :erlang.byte_size('abcd')
            |
            | iex> byte_size(to_string(a))
            | 4

      section(data-bespoke-backdrop='elixir')
        h2 Tuples
        pre
          code.elixir
            | iex> my_tuple = {:ok, "return value", 715}
            | {:ok, "return value", 715}
            | ­
            | TODO MORE

      section(data-bespoke-backdrop='elixir')
        h2 Lists
        pre
          code.elixir
            | iex> my_list = [1, 2, 3, 4, 5]
            | [1, 2, 3, 4, 5]
            | ­
            | TODO MORE (cons add, length unknown)

      section(data-bespoke-backdrop='elixir')
        h2 Maps
        pre
          code.elixir
            | iex> my_map = %{:first => "Tom", :last => "Waits"}
            | %{first: "Tom", last: "Waits"}
            | ­
            | TODO MORE (keys arbitrary (str, tuple), size unknown)

      section(data-bespoke-backdrop='elixir')
        h2 Structs
        pre
          code.elixir
            | iex> defmodule Person do
            | ...>   defstruct first: "Tom", last: "Waits"
            | ...> end
            | {:module, Person, …}
            | ­
            | iex> %Person{}
            | %Person{first: "Tom", last: "Waits"}
            | ­
            | iex> %Person{first: "Hazel"}
            | %Person{first: "Hazel", last: "Waits"}
            | ­
            | iex> %Person{nope: "Bad Field"}
            | ** (CompileError) iex:4: unknown key :nope for struct

      section(data-bespoke-backdrop='elixir')
        h2 Closures
        pre
          code.elixir
            | iex> sum = fn a, b -> a + b end
            | #Function<12.90072148/2 in :erl_eval.expr/5>
            | ­
            | iex> sum.(1, 2)
            | 3
            | ­
            | # shortened closure syntax:
            | ­
            | iex> short_sum = &(&1 + &2)
            | &:erlang.+/2
            | ­
            | iex> short_sum.(1, 2)
            | 3

      section(data-bespoke-backdrop='elixir')
        h2 Variable Sorting
        pre
          code.elixir
            | TODO
            | intersting type system

      section(data-bespoke-backdrop='elixir')
        h2 Variable Lifespan
        pre
          code.elixir
            | TODO
            | talk about garbage collection
            | when do variables disappear?

      section(data-bespoke-backdrop='elixir')
        h2 Modules & Functions
        pre
          code.elixir
            | defmodule ... def ...
            | @variable (public/private?)
            | TODO

      section(data-bespoke-backdrop='elixir')
        h2 Functions Implicit Returns
        pre
          code.elixir
            | TODO

      section(data-bespoke-backdrop='elixir')
        h2 Functions "Dreamy overloading"
        pre
          code.elixir
            | TODO
            | https://tour.golang.org/methods/16
        p More coming up in "pattern matching" section

      section(data-bespoke-backdrop='elixir')
        h2 Functions Guard Clauses
        pre
          code.elixir
            | TODO

      section(data-bespoke-backdrop='elixir')
        h2 Functions Custom Guard Clauses
        pre
          code.elixir
            | TODO

      section(data-bespoke-backdrop='elixir')
        h2 Protocols
        pre
          code.elixir
            | iex> defprotocol Stringable do
            | ...>   def to_string(value)
            | ...> end
            | ­
            | iex> defimpl Stringable, for: Person do
            | ...>   def to_string(value) do
            | ...>     "&num;{value.first} &num;{value.last}"
            | ...>   end
            | ...> end
            | ­
            | iex> Stringable.to_string(%Person{})
            | "Tom Waits"
        p.foot Some similarities to an OOP Interface

      section(data-bespoke-backdrop='elixir')
        h2 Variable re-assigning
        pre
          code.elixir
            | TODO
            | Not changing the value, reassigning to a new value

      section(data-bespoke-backdrop='elixir')
        h2 Pointers? Pass by reference?
        pre
          code.elixir
            | TODO
            | Nope... (confirm?)

      section(data-bespoke-backdrop='elixir')
        h2 Operators, Basic
        pre
          code.elixir
            | TODO
            | + - * / %

      section(data-bespoke-backdrop='elixir')
        h2 Operators, For
        pre
          code.elixir
            | TODO

      section(data-bespoke-backdrop='elixir')
        h2 Operators, For Alternatives
        pre
          code.elixir
            | TODO
            | map, filter, reduce

      section(data-bespoke-backdrop='elixir')
        h2 Operators, If / Else (bad)
        pre
          code.elixir
            | TODO

      section(data-bespoke-backdrop='elixir')
        h2 Operators, Case / Cond
        pre
          code.elixir
            | TODO

      section(data-bespoke-backdrop='elixir')
        h2 Pattern Matching
        pre
          code.elixir
            | iex> a = {:ok, 1}
            | {:ok, 1}
            | ­
            | iex> {:ok, b} = {:ok, 1}
            | {:ok, 1}
            | ­
            | iex> b
            | 1

      section(data-bespoke-backdrop='elixir')
        h2 Pattern Matching Lists
        pre
          code.elixir
            | iex> [a, b, c] = [1, 2, 3]
            | [1, 2, 3]
            | ­
            | iex> a
            | 1
            | ­
            | iex> [head | tail] = [1, 2, 3]
            | [1, 2, 3]
            | ­
            | iex> head
            | 1
            | ­
            | iex> tail
            | [2, 3]

      section(data-bespoke-backdrop='elixir')
        h2 Pattern Matching Structs
        pre
          code.elixir
            | case HTTP.get(url) do
            |   {:ok, %HTTP.Resp{ status: 200, body: body }} ->
            |     IO.puts body
            |   {:ok, %HTTP.Resp{ status: 404 }} ->
            |     IO.puts "Not found :("
            |   {:ok, %HTTP.Resp{ status: status }} ->
            |     IO.puts "HTTP Status: &num;{status}"
            |   {:error, %HTTP.Error{ reason: reason }} ->
            |     IO.inspect reason
            |   _ ->
            |     IO.puts "¯\_(ツ)_/¯"
            | end

      section
        h2 Pattern Matching in Functions
        pre
          code.elixir
            | def execute({:ok, good_value}) do
            |   IO.puts "Known good value: &num;{good_value}"
            | end
            | ­
            | def execute({:error, error_reason}) do
            |   IO.puts "Error! &num;{error_reason}"
            | end
            | ­
            | iex> execute({:ok, "Yay!"})
            | Known good value: Yay!
            | ­
            | iex> execute({:error, "Boo!"})
            | Error! Boo!

      // TODO consider more Functions examples here (overloading comparison)

      section(data-bespoke-backdrop='mind-blown')

      section(data-bespoke-backdrop='elixir')
        h2 Pipe Oporator
        pre
          code.elixir
            | iex> "tom waits"
            |      |> String.upcase
            |      |> String.replace(" ", "_")
            |      |> String.to_atom
            | :TOM_WAITS­
        p <code>|></code> passes result from last method as first param in next
        h4 Similar to unix pipe
        pre
          code.sh $ ps ax | grep iex | awk '{ print $1 }'

      section(data-bespoke-backdrop='elixir')
        h2 Pipe Oporator
        pre
          code.elixir
            | defmodule Shop do
            |   defp apply_tax(prices) do
            |     Enum.map(prices, fn v -> v * 1.1 end)
            |   end
            |   # we will improve readability in this function
            |   def cart_total(items) do
            |     Enum.sum(
            |       apply_tax(
            |         Enum.map(items, fn item -> item.price end)))
            |   end
            | end
            | iex> Shop.cart_total([%{price: 5.00}, %{price: 2.00}])
            | 7.7

      section(data-bespoke-backdrop='sad-kirk')
        h2 Without a Pipe Oporator
        pre
          code.elixir
            | def cart_total(items) do
            |   prices = Enum.map(items, fn itm -> itm.price end)
            |   prices_with_tax = apply_tax(prices)
            |   Enum.sum(prices_with_tax)
            | end

      section(data-bespoke-backdrop='happy-kirk')
        h2 With a Pipe Oporator
        pre
          code.elixir
            | def cart_total(items) do
            |   items
            |   |> Enum.map(fn item -> item.price end)
            |   |> add_tax
            |   |> Enum.sum
            | end

      section(data-bespoke-backdrop='universe')
        h2 And you have all of Erlang...
        pre
          code.elixir
            | iex> :crypto.md5("sekr1t")
            | <<192, 151, 240, 131, 252, 86, 1, 90, 71, 171, 2, …
        p Can easily leverage 20+ years of Erlang libraries

      section(data-bespoke-backdrop='nye')
        h1 You can use Elixir today
        h3 It's really easy to get started

      section
        h1 Ready to try it out?
        h3 Codelab time!

      section
        h1 Preview
        ul
          li 01-03 Greetings basics
          li 04-06 Functional Programming basics
          li 07-09 Concurrancy Programming basics
          li 10-12 OTP FTW

      section(data-bespoke-backdrop='bear')
        h2 Thank You
        h4 Alan Blount (@zeroasterisk)

    script(src='build/build.js')
